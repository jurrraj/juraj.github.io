<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="favicon.jpg" type="image/x-icon">
<style>
  html, body {
    margin: 0;
    background: #fff;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  canvas {
    flex: 1;
    display: block;
    image-rendering: pixelated;
    background: #eee;
  }

  footer {
    text-align: center;
    padding: 10px;
    font-family: Futura, sans-serif;
    font-size: 14px;
  }

  footer a {
    color: black;
    text-decoration: none;
    border: 1px solid black;
    padding: 6px 12px;
    border-radius: 4px;
  }

  footer a:hover {
    background: black;
    color: white;
  }
</style>
</head>
<body>

<canvas id="world"></canvas>
<footer><a href="inspiration.html">‚Üê Inspiration</a></footer>

<script>
const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');

let W = window.innerWidth;
let H = window.innerHeight - 50;
canvas.width = W;
canvas.height = H;

const gridSize = 10;
const cols = Math.floor(W / gridSize);
const rows = Math.floor(H / gridSize);

let tiltX = 0, tiltY = 0;
let gameOver = false;

class PixelCreature {
  constructor(x, y, color = null) {
    this.x = x;
    this.y = y;
    this.color = color || getRandomColor();
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x * gridSize, this.y * gridSize, gridSize, gridSize);
  }

  evolve() {
    // Move randomly + tilt
    if (Math.random() < 0.6) {
      let dx = Math.floor(Math.random() * 3) - 1;
      let dy = Math.floor(Math.random() * 3) - 1;
      let nx = Math.max(0, Math.min(cols - 1, this.x + dx + tiltX));
      let ny = Math.max(0, Math.min(rows - 1, this.y + dy + tiltY));
      if (!isOccupied(nx, ny)) {
        this.x = nx;
        this.y = ny;
      }
    }

    // Attack nearby creatures
    const target = getNearbyCreature(this.x, this.y);
    if (target && Math.random() < 0.08) {
      removeCreature(target);
    }

    // Slower reproduction
    if (Math.random() < 0.005) {
      const empty = getEmptyNeighbor(this.x, this.y);
      if (empty) creatures.push(new PixelCreature(empty.x, empty.y, this.color));
    }
  }
}

// Helpers
function getRandomColor() {
  const colors = ['#000000','#00cc00','#ff3300','#0033ff','#ff00ff','#00ffff'];
  return colors[Math.floor(Math.random() * colors.length)];
}
function isOccupied(x, y) { return creatures.some(c => c.x === x && c.y === y); }
function getNearbyCreature(x, y) {
  return creatures.find(c => Math.abs(c.x - x) <= 1 && Math.abs(c.y - y) <= 1 && !(c.x === x && c.y === y));
}
function getEmptyNeighbor(x, y) {
  const neighbors = [];
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      const nx = x + dx, ny = y + dy;
      if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !isOccupied(nx, ny)) {
        neighbors.push({ x: nx, y: ny });
      }
    }
  }
  return neighbors.length ? neighbors[Math.floor(Math.random() * neighbors.length)] : null;
}
function removeCreature(creature) {
  const index = creatures.indexOf(creature);
  if (index >= 0) creatures.splice(index, 1);
}

// Population
let creatures = [];
function initCreatures() {
  creatures = [];
  for (let i = 0; i < 400; i++) {
    const x = Math.floor(Math.random() * cols);
    const y = Math.floor(Math.random() * rows);
    if (!isOccupied(x, y)) creatures.push(new PixelCreature(x, y));
  }
}
initCreatures();

// Destroy circle
function destroyCircle(cx, cy, radius) {
  creatures = creatures.filter(c => {
    const dx = c.x - cx;
    const dy = c.y - cy;
    return Math.sqrt(dx*dx + dy*dy) > radius;
  });
}

// Click = destruction or restart
canvas.addEventListener('pointerdown', (e) => {
  if (gameOver) {
    gameOver = false;
    initCreatures();
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const clickX = Math.floor((e.clientX - rect.left) / gridSize);
  const clickY = Math.floor((e.clientY - rect.top) / gridSize);
  destroyCircle(clickX, clickY, 10); // radius doubled = 40 pixels
});

// Device tilt
window.addEventListener('deviceorientation', (event) => {
  tiltX = event.gamma / 15;
  tiltY = event.beta / 15;
});

// Draw loop
function drawWorld() {
  ctx.fillStyle = '#eee';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  creatures.forEach(c => { c.evolve(); c.draw(); });

  if (creatures.length === 0 && !gameOver) {
    gameOver = true;
    ctx.fillStyle = '#000';
    ctx.font = '24px Futura';
    ctx.textAlign = 'center';
    ctx.fillText('Reset', W / 2, H / 2);
    ctx.font = '16px Futura';
    ctx.fillText('Click to restart.', W / 2, H / 2 + 30);
  }

  if (!gameOver) requestAnimationFrame(drawWorld);
  else setTimeout(() => requestAnimationFrame(drawWorld), 2000);
}
drawWorld();

// Resize reset
window.addEventListener('resize', () => location.reload());
</script>

</body>
</html>
